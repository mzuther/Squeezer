\input{include/settings.sty}
\input{include/hyphenation.sty}

\title{Squeezer}
\author{Martin Zuther}

\begin{document}

\title{Squeezer}

\subtitle{
  \normalsize{\textrm{\textmd{
        \vfill
        Flexible general-purpose audio compressor \\
        with a touch of citrus
        \vfill
        \vspace{1.5em}
        \includegraphics[scale=0.35,clip]{include/images/squeezer.png}
        \vfill
      }}}
}

\author{}

\date{\emph{Last edited on \today}}

\dedication{
  \includegraphics[scale=0.65,clip]{include/images/cc-by-sa.png}
  \vspace{0.25em}

  This documentation by \href{http://www.mzuther.de/}{Martin Zuther}
  is licensed under a
  \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative
    Commons Attribution-ShareAlike 4.0 International License} with the
  exception of trademark logos.

  \vspace{2.5em}

  \includegraphics[scale=0.55,clip]{include/images/VST_Compatible_Logo_Steinberg_negative.png}

  VST is a trademark of Steinberg Media Technologies GmbH,
  registered in Europe and other countries.
}

\maketitle

\tableofcontents

\clearpage  % layout

\chapter{About Squeezer}
\label{chap:about_squeezer}

\emph{I wrote this compressor\footnote{In this manual, I will use
    \emph{compression} synonymous with \emph{downward compression}.
    There are other ways to reduce dynamic range, but in audio,
    downward compression is used almost exclusively.} to learn all I
  could about audio compression.  It took me several months to gather
  all the specs and papers I needed and convert them into code.}

Squeezer is different from all the compressors I know: its knobs are
stepped to fine-tuned \emph{preset} values, but can be changed to
\emph{continuous} values by clicking a small orange light located next
to them.  This allows you to find nice settings fast while not
preventing optimisation of settings.

Squeezer adapts easily to many tastes and use cases:

\begin{itemize}
\item feed-forward \& feed-back design
\item linear, logarithmic \& smooth release stage
\item optical \& FET detectors
\item peak \& RMS sensing
\item hard, medium \& soft knee
\item flexible side-chain \& parallel compression
\end{itemize}

Squeezer has given me a deep insight into compression.  But above
that, it has quickly become my go-to generic compressor.

\emph{I hope that you have as much fun with Squeezer as I had when I
  coded it!}

\chapter{What is compression?}
\label{chap:what_is_compression}

\section{The Tale of the Barkeeper}
\label{sec:compression_tale_of_barkeeper}

Once upon a time there was a bar.  Customers enjoyed their drinks and
music played in the background.  After a while, the barkeeper noticed
that his drinks sold best when the music had a certain loudness.
Unfortunately, almost every record they played had a different
loudness.

So he bought a loudness meter and wrote a set of instructions for the
DJ:

\begin{tabular}{p{0.2 \textwidth}p{0.8 \textwidth}}

  \textbf{\SI{80}{\dBSPL}} &
  set mixer's output gain to \SI{0}{\dB} \\[0.5em]

  \textbf{\SI{85}{\dBSPL}} &
  set mixer's output gain to \SI{-5}{\dB} \\[0.5em]

  \textbf{\SI{90}{\dBSPL}} &
  set mixer's output gain to \SI{-10}{\dB} \\[0.5em]

  \textbf{\SI{95}{\dBSPL}} &
  set mixer's output gain to \SI{-15}{\dB} \\[0.25em]

\end{tabular}

This worked quite well and he could finally afford to buy a shiny new
bar counter.  Upon which the DJ gave notice (he had always dreamt of
getting a \emph{stereo} mixer, so the new counter didn't go down too
well with him).

After an initial shock, the barkeeper was quite content.  The DJ
really \emph{had} been lousy.  But how to keep the impressive sales
figures for his drinks?

Being an entrepreneur, the barkeeper loved challenges and connected
the mixer's output to a simple amplifier.  The amplifier's gain was
regulated by a level sensor which in turn was connected to the
amplifier's output.\footnote{engineers call this a negative feed-back
  loop}

Although the new device exactly followed the DJ's instructions (and
didn't smell as bad), customers complained about a decline in sound
quality.  The barkeeper had invented a \emph{wave shaping} device --
gain changes were applied instantly which \emph{distorted} its output
signal.

Fortunately, the barkeeper remembered a very important thing: the DJ
had often been drunk and taken his time to apply gain changes.  So the
barkeeper improved his device by smoothing the level sensor's output.

He could have become very rich.  But he didn't realise the magnitude
of his invention and continued being a happy barkeeper.  Which is not
the worst thing, when you come to think of it.

To this day, however, sound engineers fall silent in awe when they
hear his name -- the name of the barkeeper who \textbf{invented the
  compressor}.

\section{How does a compressor work?}
\label{sec:how_does_a_compressor_work}

\emph{Compressors are inherently complex sound processors.  Their
  technology is quite simple -- complexity arises from the dynamic
  interaction of their controls.  While this is definitely a downside
  when you try to understand compression, it is also what allows you
  to use compression creatively!}

A compressor is a device for reducing the dynamic
range\footnote{difference between loudest and quietest signal} of audio
material.  In its most basic form, it consists of four modules:

\begin{tabular}{p{0.3 \textwidth}p{0.625 \textwidth}}

  \textbf{Level detector} &
  measures level of audio at its input and sends it to gain
  computer \\

  \textbf{Gain computer} &
  calculates difference between input level and desired output level
  and sends resulting \emph{target} gain reduction to smoothing
  filter \\

  \textbf{Smoothing filter} &
  smoothly adjusts \emph{current} gain reduction in direction of
  \emph{target} reduction and sends result to gain stage; the
  ``speed'' of smoothing can often be adjusted (\emph{attack and
    release times}) \\

  \textbf{Gain stage} &
  attenuates audio input by \emph{current} gain reduction \\

\end{tabular}

The first three modules are also called \emph{side-chain}.  That's
because they form a sideline of processing that will only be
\emph{utilised for}, but not \emph{heard in} the compressor's output.

\section{Level detector}
\label{sec:level_detector}

As its name implies, a level detector senses the level of an audio
signal.  It can either detect the input wave form directly (peak
sensing) or an estimate of its loudness (average sensing, usually with
a RMS\footnote{root mean square} filter).

\emph{Peak sensing} allows a compressor to quickly react to sudden
changes in level, whereas \emph{average sensing} detects changes over
longer periods of time.

There are also two ways of connecting level detectors: vintage
compressors sense the gain stage's \emph{output} level (feed-back
design), leading to a very distinct ``bouncing'' sound.  Modern
compressors sense the compressor's \emph{input} signal (feed-forward
design) which often results in a more natural sound.

\section{Gain computer}
\label{sec:gain_computer}

The level detector's signal is sent to a gain computer\footnote{in the
  sense of \emph{calculator} -- some gain computers are entirely built
  from analogue circuitry!} which determines the output level the
signal should have.  It then calculates a corresponding gain reduction
(``attenuate the current input signal by \SI{3.14}{\dB}'').  This
\textbf{gain reduction constantly changes} over time.

The most common gain computer design is a \emph{threshold} control.
It sets a level below which all input passes unchanged.  Levels
exceeding the threshold are attenuated by a \emph{compression ratio},
set through a second control.  Higher ratios effect more compression
than lower ratios.\footnote{a compression ratio of 1:1 effectively
  bypasses the compressor}

Need an example?  A threshold of \SI{-20}{\dBFS} yields a gain
reduction of \SI{0}{\dB} (no compression) for all levels below
\SI{-20}{\dBFS}.  A signal of \SI{-18}{\dBFS} however will produce a
gain reduction of \SI{1}{\dB} for a compression ratio of
2:1\footnote{a ratio of 2:1 means that \SI{2}{\dB} on the input yields
  \SI{1}{\dB} at the output} and \SI{0.5}{\dB} for a ratio of 4:1.

There may be a third control called \emph{knee width}. It defines a
transition zone around the threshold.  In this zone, the compression
ratio gradually changes from 1:1 (no compression) to the selected
ratio (full compression) -- quieter signals receive less compression
than louder ones.  This reduces distortion caused by abrupt
transitions between compressed and uncompressed signal.

\section{Smoothing filter}
\label{sec:smoothing_filter}

\emph{This was the easy part, but from now on most explanations start
  to fail.  I'll try my best and continue anyway \dots}

If you stopped here and let the gain computer control the gain stage
directly, you'd have a wave shaping device.\footnote{\emph{wave
    shaping} is a fancy way of saying \emph{distortion}} By reacting
immediately, the compressor would relentlessly change the shape of
\emph{single wave forms}.  Don't get me wrong: this already \emph{is}
compression and I occasionally \emph{do} like its sound -- but it's
not something you want to have on every track, let alone a full mix.

\emph{Listen for yourself!  Load a drum track into your DAW, add the
  Squeezer plug-in, unlock attack and release time\footnote{click on
    the orange light next to a knob so it lights up} and set them to
  the lowest possible value.  Make sure the compressor uses peak
  sensing\footnote{``RMS'' button is not engaged} and a high
  compression ratio.  Now lower the threshold until you can clearly
  hear the wave shaping.  Keep the DAW open for now.}

To change \emph{sounds} instead of \emph{single wave forms}, the
\emph{current} gain reduction has to be slowed down and smoothly
adjusted in the direction of the \emph{target} gain reduction.

One possibility is using averaging level detectors,\footnote{this is
  \emph{not} the reason why compressors have averaging level
  detectors; they let compressors react to changes in \emph{loudness}}
employing photo (``optical'' or ``opto'') cells is
another.\footnote{photo cells react to level changes in complex
  time-dependant ways} Both solutions effectively slow down the
compressor's response time, but somewhat crudely.

\emph{Play the drum track and engage the ``RMS'' button -- the
  distortion vanishes.  Disengage the ``RMS'' button and enable the
  ``Opto'' button instead -- again, the distortion vanishes, but the
  track sounds different.  You can now close the DAW.}

\subsection{Attack and release time}
\label{sec:attack_and_release_time}

With a little experimentation, it becomes clear that compressors sound
best when gain reduction is increased quickly, but released much more
slowly.\footnote{incidentally, that is \emph{exactly} how vintage
  photo cells react to changes} Moreover, a single smoothing ``speed''
could not accommodate the many different types of sound we encounter.
So it makes sense to split response time into (at least) two controls:

\emph{Attack} is the length of time it takes to apply
roughly\footnote{every manufacturer defines attack and release times
  differently} two-thirds of an \emph{upward} change in gain
reduction.

\emph{Release} is the length of time it takes to apply roughly
two-thirds of a \emph{downward} change in gain
reduction.\footnote{these definitions were shamelessly paraphrased
  from
  \href{https://www.attackmagazine.com/features/columns/gregory-scott-demolishing-the-myths-of-compression/}{Demolishing
    the Myths of Compression} by Gregory Scott, one of the few
  articles on compression actually worth reading}

With this in mind, here are the important facts that almost every
explanation gets wrong:\footnote{for simplicity, I will elide the
  effects of knee width}

\begin{itemize}
\item compression starts \textbf{the very moment the detected level
    passes threshold}, it is not delayed by attack time
\item compression continues \textbf{even after the detected level
    falls below threshold}, at least for a short while
\item compression occurs \textbf{whenever \emph{current} and
    \emph{target} gain reduction differ}; this means \textbf{all of
    the time the detected level is above threshold} and slightly after
\end{itemize}

The last list item may need some explanation.  Imagine a signal above
threshold.\footnote{with a compression ratio above 1:1 and below 1:∞}

Whenever the signal's slope is rising, \emph{current} gain reduction
will fall below \emph{target} gain reduction and will be smoothed
using the \emph{attack} time.  Even when the slope starts to drop,
\emph{current} gain reduction may still be below \emph{target} gain
reduction and will be affected by the attack time.

If the slope keeps falling, \emph{current} gain reduction will
eventually rise above \emph{target} gain reduction and will be
smoothed according to the \emph{release} time.  This continues until
the slope starts to rise again and \emph{current} gain reduction falls
below \emph{target} gain reduction.  Now, the \emph{attack} time will
once again take over.

In other words: with any real-world audio signal, compressors enter an
ever-changing dynamic state as soon as the input signal passes
threshold.  This is what makes them so hard to explain -- and I'm
quite confident that it is also what makes them sound so damn good.

The good news is that you can use compressors without fully
understanding this dynamic state.  However, the information contained
in this chapter will help you in ignoring the countless erroneous
explanations out there.\footnote{they were the reason for developing
  Squeezer in the first place}

\subsection{Curve shape}
\label{sec:curve_shape}

Attack and release times can be implemented in a number of ways.
Vintage compressors use simple analogue filters with
\emph{logarithmic} curves.  Speed depends on the difference between
\emph{current} and \emph{target} gain reduction -- initial change is
fast and slows down as the difference gets smaller.

Newer compressors often have \emph{linear} curves -- the \emph{target}
gain reduction is approached with constant speed.

In Squeezer, attack phase always has a \emph{logarithmic} curve.  The
curve of its release phase can be set to \emph{linear},
\emph{logarithmic} or \emph{smooth}.  \emph{Smooth} behaves like a
logarithmic curve, but when an attack phase changes to release, a
smooth transition between the curves prevents a sharp drop in gain
reduction.  This reduces yet another type of distortion exhibited by
compressors.

It is hard to say which curve sounds best, as it really depends on
source material and personal taste.

\section{Gain stage}
\label{sec:gain_stage}

The gain stage is an amplifier that attenuates the input signal using
the \emph{current} gain reduction.  There may be an additional gain
control to make up for any level lost during compression (also called
\emph{make-up gain}).

That's it.

\section{Advanced topics}
\label{sec:advanced_topics}

\subsection{Stereo linking}
\label{sec:stereo_linking}

When each channel of a stereo signal is compressed separately, the
stereo image may shift uncontrollably.  This can be prevented by
mixing the outputs of all level detectors and sending the \emph{mixed}
signal to each gain computer.

Squeezer automatically links its channels when placed on a stereo
channel.  Occasionally, you may want to override this behaviour, so
Squeezer lets you control the amount of stereo linking.

\subsection{Parallel compression}
\label{sec:parallel_compression}

So far, I have described \emph{downward} compression.  As you know, it
works by bringing high-level signals down and leaving low-level
signals untouched.  In other words, downward compression changes --
and possibly damages -- the \emph{transients}.

This may not be what you want, so \emph{upward} compression works the
other way round.  Low-level signals are brought up and high-level
signals are left alone.  This approach has a huge problem, though --
it also amplifies the noise floor!  This is probably the reason why I
have never seen an upward compressor in the wild \dots

\emph{Parallel} compression\footnote{also known as \emph{New York
    compression}, but in this case, the signal is also equalised prior
  to compression} is similar to \emph{upward} compression, but it
preserves transients \emph{and} leaves the noise floor alone.  Here is
how it works: you compress a signal (often heavily) and add some of
the compressed signal to the original.

Squeezer provides a latency-compensated \emph{wet/dry} control that
allows you to apply parallel compression easily.

\subsection{Side-chain filtering}
\label{sec:side_chain_filtering}

Bass frequencies contain most of a signal's energy, so bus compression
will often ``pump'' in the rhythm of the bass instruments.\footnote{in
  addition, music tends to contain more bass frequencies than treble
  as the human ear is least sensitive to bass frequencies} A filter
that removes bass frequencies (\emph{high-pass} filter) from the
side-chain helps in achieving better compression results.

Squeezer also provides a \emph{low-pass} filter to remove treble
frequencies, although this is used less often.  For frequency-specific
compression, you can leave only desired frequencies by employing both
filters simultaneously.

\subsection{External side-chain input}
\label{sec:external_side_chain}

Squeezer also lets you feed an external input into the side-chain.
You can use this either for advanced filtering or as an effect.  In
electronic dance music, compressor ``pumping'' triggered by the bass
drum has become rather cliché \dots

Depending on your DAW, setting up an external side-chain can be simple
or highly complicated.  I cannot (and will not) help you with it, so
please refer to your DAW's manual or manufacturer.  I will however
provide some information to get you started.

The input channels of Squeezer's stand-alone application and VST2
plug-in are \emph{doubled} and divided into main inputs (first half of
the channels) and side-chain inputs (second half).

The other plug-in formats are properly tagged.  They notify your DAW
about each channel's role and should work without problem.

\chapter{Installation}
\label{chap:installation}

In order to use the pre-compiled binaries, simply extract Squeezer's
files from the downloaded archive.  For the plug-ins, you'll then have
to move the extracted files to your respective plug-in folder.

Squeezer requires a processor which supports the SSE2 instruction set.
On Windows, you might also have to install the
\href{https://www.visualstudio.com/downloads/}{Visual C++
  Redistributable for Visual Studio 2017}.

Should the stand-alone version ever fail to start, you can reset its
settings by deleting the file \path{Squeezer (Stereo).ini} or
\path{Squeezer (Mono).ini}.  These files are located in
\path{~/.config} (GNU/Linux) or \path{%appdata%\.config\} (Windows).

\chapter{Troubleshooting}
\label{chap:troubleshooting}

\textbf{My DAW acts weirdly if I insert Squeezer (VST2).}

VST2 doesn't support side-chains, so I had to use a hack.  It works
with a few DAWs, but \textbf{FL Studio} for example outputs a mono
signal if you insert a stereo instance of Squeezer.

Please use the VST2 plug-ins with ``\path{no side-chain}'' in their
name -- they disable external side-chain input.  In case you need an
external side-chain, please use VST3 plug-ins (VST3 officially
supports side-chains).

\chapter{Knobs}
\label{sec:knobs}

\section{Unlock knobs}
\label{sec:unlock_knobs}

\begin{wrapfigure}{r}{0.26\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_toggle_locked.png}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_toggle_unlocked.png}
\end{wrapfigure}

By default, Squeezer's knobs are stepped to \emph{preset} values.  I
have invested a lot of time to fine-tune these values and ensure that
they are useful in practice.

If you need finer control, however, every knob can be changed to
\emph{continuous} values.  Just click the small orange light located
in its upper right corner.

Depending on your action, Squeezer either preserves your current
setting or snaps to the value closest to it.

\newpage %% layout

\section{Threshold and compression ratio}

\begin{wrapfigure}{r}{0.26\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_threshold.png}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_compression_ratio.png}
\end{wrapfigure}

These knobs control \textbf{threshold} and compression ratio.

A \textbf{compression ratio} of 2:1 means that \SI{1}{\dB} on the
input yields \SI{0.5}{\dB} at the output.  Thus, a setting of 1:1
effectively disables Squeezer.

You can set this knob to values below 1:1.  This transforms Squeezer
into an \emph{upward expander} -- an \textbf{expansion ratio} of 0.5:1
means that \SI{1}{\dB} on the input yields \SI{2}{\dB} at the output.
This allows you to \emph{add transients} to boring and over-compressed
recordings.

\textbf{Note: upward expansion can massively \emph{increase} the
  output level, so take care of you ears -- especially when you switch
  from compression to expansion!}

\section{Attack and release time}

\begin{wrapfigure}{r}{0.26\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_attack_time.png}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_release_time.png}
\end{wrapfigure}

Change attack and release time using these two knobs.

\textbf{Attack} is the length of time it takes to apply
\SI{90}{\percent} of an upward change in gain reduction.

\textbf{Release} is the length of time it takes to apply
\SI{90}{\percent} of a downward change in gain reduction
(\emph{logarithmic} and \emph{smooth} curves).  Alternatively, this is
the length of time it takes gain reduction to fall by \SI{10}{\dB}
(\emph{linear} curve).\footnote{often called release \emph{rate}
  because the actual release \emph{time} depends on the amount of
  applied gain reduction; linear release curves can sound very
  different from logarithmic ones}

\section{Input trim and output gain}
\label{sec:input_trim_and_output_gain}

\begin{wrapfigure}{r}{0.26\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_input_trim.png}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_output_gain.png}
\end{wrapfigure}

\textbf{Trim} changes Squeezer's input gain without affecting its
output level.  \emph{You can also think of this as attenuating
  threshold by the value of trim.}

\textbf{Output} controls output gain (also called make-up gain).
There are several use cases:

\begin{itemize}
\item use \emph{output gain} to match the loudness of compressed and
  direct signal before comparing them\footnote{the brain perceives a
    louder signal to sound better than a quieter one}

\item set the threshold to a fixed value and control Squeezer
  \emph{vintage style} by changing \emph{trim} and \emph{output gain}
  only

\item use \emph{trim} for gain staging to improve automatic make-up
  gain (\ref{sec:buttons_automatic_makeup_gain})

\item if Squeezer sounds well and the level of the incoming signal
  changes for some reason, it may be more obvious to adjust
  \emph{trim} instead of \emph{threshold}
\end{itemize}

\section{Stereo linking and wet/dry ratio}

\begin{wrapfigure}{r}{0.26\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_stereo_link.png}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_wet_dry.png}
\end{wrapfigure}

\textbf{Link} controls the amount of stereo linking.
\SI{100}{\percent} enforces full linking, whereas \SI{0}{\percent}
disables linking and processes every channel independently.

\textbf{Wet} controls the ratio between wet (compressed) and dry
(uncompressed) signal.  When set to \SI{100}{\percent}, you hear only
compressed signal.  A value of \SI{50}{\percent} yields an equal mix
of compressed and direct signal, and \SI{0}{\percent} effectively
bypasses Squeezer.

Mixing is latency-compensated, so you can use the wet control to
employ \emph{parallel compression}.

\section{Side-chain filters}

\begin{wrapfigure}{r}{0.26\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_hpf_cutoff.png}
  \includegraphics[scale=\screenshotscale,clip]{include/images/knob_lpf_cutoff.png}
\end{wrapfigure}

The side-chain is equipped with a high-pass filter and a low-pass
filter.  These knobs control their \textbf{cutoff frequencies}.

Both filters are connected in series so you can use them
simultaneously to remove everything but a specific band of
frequencies.

\chapter{Buttons}
\label{sec:buttons}

\section{Release curve type}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/buttons_release_curve.png}
\end{wrapfigure}

Attack phase always has a \emph{logarithmic} curve.  Use these buttons
to change the \emph{release phase}.  All options (\textbf{linear},
\textbf{logarithmic} and \textbf{smooth} curve) are detailed in
\ref{sec:curve_shape}.

\section{Detector placement}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_feedback_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_feedback_off.png}
\end{wrapfigure}

Engaging the \textbf{feed-back} button places the level detector at
the gain stage's output.  Otherwise, the detector is fed with the
uncompressed input signal (\textbf{feed-forward}).

\newpage %% layout

\section{RMS filter}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_rms_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_rms_off.png}
\end{wrapfigure}

This button switches the detector between peak-sensing and
average-sensing using an \textbf{RMS} filter (window size of
\SI{30}{\milli\second}).  RMS filter and the ``Opto'' detector type
are independent -- both buttons can be engaged at the same time.

\section{Detector type}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_opto_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_opto_off.png}
\end{wrapfigure}

Engage this button to switch between the linear response of a
field-effect transistor (\textbf{FET}) and a photo cell emulation
(\textbf{Opto}).  Detector type and ``RMS'' filter are independent --
both buttons can be engaged at the same time.

\section{Knee width}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/buttons_knee_width.png}
\end{wrapfigure}

These buttons let you select the compressor's knee width.
\textbf{Hard} abruptly transitions between compressed and uncompressed
signal at the threshold.  \textbf{Medium} sets a knee width of
\SI{24}{\dB}\footnote{transition zone starts \SI{12}{\dB} below
  threshold and ends \SI{12}{\dB} above} and \textbf{soft} a knee
width of \SI{48}{\dB}.

\section{External side-chain}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_sidechain_external_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_sidechain_external_off.png}
\end{wrapfigure}

Use this button to feed Squeezer's side-chain with an
\textbf{external} signal.  For more information, please see
\ref{sec:external_side_chain}.

\section{Listen to side-chain}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_sidechain_listen_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_sidechain_listen_off.png}
\end{wrapfigure}

\textbf{Listen} to the internal or external side-chain by clicking
this button.  If you have engaged the side-chain filters, you will
hear the \emph{filtered} signal.

\section{Automatic make-up gain}
\label{sec:buttons_automatic_makeup_gain}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_auto_makeup_gain_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_auto_makeup_gain_off.png}
\end{wrapfigure}

When this button is engaged, Squeezer tries to counter the jumps in
level caused by changing threshold and compression ratio.

Implementing \textbf{automatic make-up gain} is an exercise in
compromise, so its quality depends on the incoming signal's level
(among a lot of other factors).  Changing input trim
(\ref{sec:input_trim_and_output_gain}) can sometimes improve results.

\newpage %% layout

\section{Bypass compression}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_bypass_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_bypass_off.png}
\end{wrapfigure}

Click on this button to \textbf{bypass} Squeezer.  I regard this as
the most important control of any compressor, as its easy to
\emph{deteriorate} a signal by compression without noticing it.

Thus, I recommend matching the levels of compressed and uncompressed
signal (see \ref{sec:input_trim_and_output_gain}) and comparing them
by toggling the bypass button.

\section{Reset button}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_reset_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_reset_off.png}
\end{wrapfigure}

A click on this button \textbf{resets} all meters.  This action will
also reload the current skin and re-draw everything.

\section{Select a skin}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_skin_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_skin_off.png}
\end{wrapfigure}

Click on this button to select a new Squeezer \textbf{skin}.  You can
also set a default skin that will be loaded when new plug-in instances
are started.

\newpage %% layout

\section{View and copy settings}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_settings_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_settings_off.png}
\end{wrapfigure}

Display all of Squeezer's \textbf{settings} with a click on this
button.  This information is also copied to the clipboard for pasting
into a text editor.

\emph{I wrote Squeezer while attending a course on compression and
  this feature made my life much easier.}

\section{About button}

\begin{wrapfigure}{r}{0.14\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_about_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_about_off.png}
\end{wrapfigure}

Clicking on this button will open the \textbf{about window} where you
will be informed about version number, contributors, copyright and the
GNU General Public License.

\section{Display license}

\begin{wrapfigure}{r}{0.15\linewidth}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_gpl_on.png}
  \newline \vspace{-0.9\baselineskip}
  \includegraphics[scale=\screenshotscale,clip]{include/images/button_gpl_off.png}
\end{wrapfigure}

This button is located in the \textbf{about window} and does not only
advertise that you are using free software licensed under the
\textbf{GNU General Public License} -- when clicked, it will also open
the license's website in your browser \dots

\chapter{Meters}
\label{chap:meters}

\section{Input and output level}

\begin{wrapfigure}{r}{0.19\linewidth}
\includegraphics[scale=0.58,clip]{include/images/meter_levels.png}
\end{wrapfigure}

Squeezer's \textbf{level meters} consist of an average level meter
(coloured bar) and a peak level meter (single coloured segment riding
on top).  The meters are divided into steps of \SI{2}{\dB} and exhibit
a flat frequency response.

The \emph{average} level meter reaches \SI{99}{\percent} of the final
reading in \SI{300}{\milli\second}, whereas the \emph{peak} level
meter has a rise time of one sample and a fall time of
\SI{8.67}{\dB\per\second}.

\section{Gain reduction}

\begin{wrapfigure}{r}{0.13\linewidth}
\includegraphics[scale=0.58,clip]{include/images/meter_gain_reduction.png}
\end{wrapfigure}

The \textbf{gain reduction meter} is divided into steps of \SI{1}{\dB}
and displays \emph{current} gain reduction.  It also indirectly
reflects ratio, attack and release time.

\emph{The gain reduction meter should always be in motion.  If a part
  of the meter is always lit, consider reducing the threshold.}

\chapter{Final words}
\label{chap:final_words}

I want to express my gratitude to the \textbf{Audio Engineering
  Society} and to the \textbf{Rane Corporation} for their wonderful
E-Libraries.  This includes everybody who wrote the fine papers and
notes, especially Dimitrios Giannoulis \emph{et
  al.}\footnote{\textbf{Giannoulis, Dimitrios; Massberg, Michael;
    Reiss, Joshua D.}  Digital Dynamic Range Compressor Design -- A
  Tutorial and Analysis. \emph{JAES Volume 60 Issue 6 pp. 399-408;
    June 2012.}} and Rick Jeffs \emph{et al.}\footnote{\textbf{Rick
    Jeffs; Scott Holden; Dennis Bohn.}  Dynamics Processors --
  Technology \& Application Tips.  \emph{Rane Corporation; Rane Note
    155; 2005.}}

I must also thank the \textbf{beta testers} and \textbf{users of
  Squeezer} for sending kind words, suggestions and bug reports.
Finally, I want to thank the \textbf{open source community} for making
all of this possible.

Although coding Squeezer has been a lot of fun, it has also been a lot
of work.  So if you like Squeezer, why not send me a short email and
tell me so?  Write a few words about yourself, send suggestions for
future updates or volunteer to create a nice skin.  I also really
enjoy listening to music that you have produced using my software
\dots

\newpage %% layout

Here is my email address (please remove ``\texttt{-nospam}''):

\begin{center}
  \texttt{"Martin Zuther" <code-nospam@mzuther.de>}
\end{center}

Thanks for using free software.  I hope you'll enjoy it!

\appendix

\chapter{Build Squeezer}
\label{chap:build_squeezer}

\section{Dependencies}
\label{sec:dependencies}

\subsection{premake}
\label{sec:dependencies_premake}

\begin{tabbing}
  \hspace*{6em}\=\=\kill

  Importance:  \> required \\
  Version:     \> 5.0.0 (alpha13) \\
  License:     \> BSD \\
  Homepage:    \> \href{https://premake.github.io/}{premake.github.io}
\end{tabbing}

\subsubsection{Installation}

Place the binary somewhere in your \path{PATH}.  Depending on your
platform, you should run \path{premake} using the scripts
\path{Builds/run_premake.sh} or \path{Builds/run_premake.bat}.

To change the premake file using the provided Jinja templates, you'll
also have to install the necessary dependencies.

\subsection{JUCE library}

\begin{tabbing}
  \hspace*{6em}\=\=\kill

  Importance:  \> required \\
  Version:     \> 5.3.2 \\
  License:     \> ISC and GPL v3 (among others) \\
  Homepage:    \> \href{http://www.juce.com/}{www.juce.com}
\end{tabbing}

\subsubsection{Installation}

Extract the archive into the directory \path{libraries/juce}.

If you want to build the LV2 plug-in, please extract the archive
\path{distrho_lv2-xxxxxxxx.tar.gz} into the same directory.

\subsection{Virtual Studio Technology SDK}

\begin{tabbing}
  \hspace*{6em}\=\=\kill

  Importance:  \> optional \\
  Version:     \> 2.4 / 3.6.8 \\
  License:     \> proprietary / GPL v3 \\
  Homepage:    \> \href{http://www.steinberg.net/en/company/developer.html}{www.steinberg.net}
\end{tabbing}

\subsubsection{Installation}

Just extract the archive into the directory \path{libraries/vst}.

\subsection{Python}

\begin{tabbing}
  \hspace*{6em}\=\=\kill

  Importance:  \> optional \\
  Version:     \> 3.5 (or higher) \\
  License:     \> Python Software Foundation License \\
  Homepage:    \> \href{http://www.python.org/}{www.python.org}
\end{tabbing}

You'll only need Python if you want to change the premake file (see
\ref{sec:dependencies_premake}) using Jinja templates.

\subsubsection{Installation (Windows)}

You can download an installer from the website.

\subsection{Jinja}

\begin{tabbing}
  \hspace*{6em}\=\=\kill

  Importance:  \> optional \\
  Version:     \> 2.8 (or higher) \\
  License:     \> BSD \\
  Homepage:    \> \href{http://jinja.pocoo.org/}{jinja.pocoo.org}
\end{tabbing}

You'll only need Jinja if you want to change the premake file using
templates (see \ref{sec:dependencies_premake}).

\subsection{Artistic Style}

\begin{tabbing}
  \hspace*{6em}\=\=\kill

  Importance:  \> optional \\
  Version:     \> 2.05.1 \\
  License:     \> LGPL v3 \\
  Homepage:    \> \href{http://astyle.sourceforge.net/}{astyle.sourceforge.net}
\end{tabbing}

This application formats the code so it looks more beautiful and
consistent.  Thus, you only have to install it if you plan to help me
with coding Squeezer.

\subsubsection{Installation}

Place the binary somewhere in your \path{PATH}.  Depending on your
platform, you should run \path{astyle} using the scripts
\path{Source/format_code.sh} or \path{Source/format_code.bat}.

\newpage %% layout

\section{GNU/Linux}

\subsection{Environment}

To build Squeezer yourself, I recommend setting up a \texttt{chroot}
environment.  This is fast and easy to do on Debian-based systems and
might save you a \textbf{lot} of trouble.  At the time of writing, I'm
using Linux Mint 19, but the procedure should be similar on your
distribution of choice.

Start by installing the necessary packages:

\begin{VerbatimBoth}
  sudo apt-get install debootstrap schroot
\end{VerbatimBoth}

Then install the \texttt{chroot} base system by executing the
following statements:

\begin{Verbatim32}
  sudo debootstrap --variant=buildd \
    --arch i386 bionic \
    /srv/chroot/bionic_i386 \
    http://archive.ubuntu.com/ubuntu
\end{Verbatim32}

\begin{Verbatim64}
  sudo debootstrap --variant=buildd \
    --arch amd64 bionic \
    /srv/chroot/bionic_amd64 \
    http://archive.ubuntu.com/ubuntu
\end{Verbatim64}

Running \path{debootstrap} will take some time.  Meanwhile, add the
following lines to \path{/etc/schroot/schroot.conf} (make sure you
remove all preceding white space so that each line begins in the first
column):

\begin{VerbatimBoth}
  [bionic-i386]
  description=Ubuntu bionic (i386)
  directory=/srv/chroot/bionic_i386
  profile=default
  personality=linux32
  type=directory
  users=username

  [bionic-amd64]
  description=Ubuntu bionic (amd64)
  directory=/srv/chroot/bionic_amd64
  profile=default
  personality=linux
  type=directory
  users=username
\end{VerbatimBoth}

Please make the necessary changes to \texttt{username}.  If you
experience problems, you can try to change \texttt{bionic} to a
release name such as \texttt{wheezy}.

When \path{debootstrap} is done, log in as superuser:

\begin{Verbatim32}
  sudo schroot -c bionic-i386
\end{Verbatim32}

\begin{Verbatim64}
  sudo schroot -c bionic-amd64
\end{Verbatim64}

You'll have to change the file \path{/etc/apt/sources.list} first
(ignore the line break, it should be a single line):

\begin{VerbatimBoth}
  deb http://archive.ubuntu.com/ubuntu bionic
  main restricted universe
\end{VerbatimBoth}

Now install a few packages -- \path{less} and \path{vim} are optional,
but might come in handy:

\begin{VerbatimBoth}
  apt-get update
  apt-get -y install bash-completion clang \
    libasound2-dev libjack-jackd2-dev \
    mesa-common-dev xorg-dev less vim
  apt-get clean
\end{VerbatimBoth}

If you like \path{bash} completion, you might also want to open the
file \path{/etc/bash.bashrc} and unquote these lines:

\begin{VerbatimBoth}
  # enable bash completion in interactive shells
  if [...]
    [a couple of lines...]
  fi
\end{VerbatimBoth}

Finally, log out and log in as normal user:

\begin{Verbatim32}
  schroot -c bionic-i386
\end{Verbatim32}

\begin{Verbatim64}
  schroot -c bionic-amd64
\end{Verbatim64}

In this \path{chroot} shell, install the dependencies
(\ref{sec:dependencies}).  Congratulations -- you are now ready to
build Squeezer!

\subsection{Build}

After preparing the dependencies, start your \texttt{chroot}
environment

\begin{Verbatim32}
  schroot -c bionic-i386
\end{Verbatim32}

\begin{Verbatim64}
  schroot -c bionic-amd64
\end{Verbatim64}

change into the directory \path{build} and execute

\begin{VerbatimBoth}
  ./run_premake.sh
  make config=CFG TARGET
\end{VerbatimBoth}

where \application{CFG} is one of \application{debug\_x32},
\application{debug\_x64}, \application{release\_x32} and
\application{release\_x64}, and \application{TARGET} is the version
you want to compile, such as \application{linux\_standalone\_stereo}.

In case you run into problems, you can try to switch compilers by
opening the file \texttt{run\_premake.sh} and using the premake
options \texttt{--cc=clang} or \texttt{--cc=gcc}.

The compiled binaries will end up in the directory \path{bin}.

\section{Microsoft Windows}

\subsection{Build}

After preparing the dependencies, change into the directory
\path{build} and execute

\begin{VerbatimBoth}
  ./run_premake.bat
\end{VerbatimBoth}

Then change into the directory \path{Builds/windows/vs20xx}, open the
project file with the corresponding version of Visual C++ and build
the project.

The compiled binaries will end up in the directory \path{bin}.

\chapter{Licenses}

\scriptsize
\input{include/gpl_v3.tex}
\normalsize

\scriptsize
\input{include/cc-by-sa-4.0.tex}
\normalsize

\end{document}


%%% Local Variables:
%%% mode: latex
%%% mode: outline-minor
%%% TeX-command-default: "Rubber"
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "british"
%%% End:
